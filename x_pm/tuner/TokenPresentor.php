<?php

/** @noinspection PhpIllegalPsrClassPathInspection */
namespace pm\tuner;

class TokenPresentor{
	const FLAG_OBFUSCATE = 2;
	const FLAG_APPEND_ORIGINAL_BASE64 = 0;
//	const FLAG_APPEND_ORIGINAL_BASE64 = 4;
	private $flags;
	public function __construct($flags){
		$this->flags = $flags;
	}
	/**
	 * @param string $file
	 * @param string $originalContents
	 * @param PhpToken[] $tokens
	 * @return string
	 */
	public function present(/** @noinspection PhpUnusedParameterInspection */
		$file, $originalContents, $tokens){
		$output = "";
		/** @var int|null $lastChar ASCII character code of the last token's trimmed last character */
		$lastChar = null;
		foreach($tokens as $token){
			$text = $token->text;
			if(($this->flags & self::FLAG_OBFUSCATE) === self::FLAG_OBFUSCATE){
				if($token->type === T_WHITESPACE or $token->type === T_COMMENT){
					continue;
				}
				$text = trim($text);
				if($lastChar !== null){
					$firstChar = substr($text, 0, 1);
					if($this->isNonSymbol(ord($firstChar)) and $this->isNonSymbol($lastChar)){
						$text = " $text";
					}
				}
			}
			$output .= $text;
		}
		$output .= "/*
 * The .phar file containing this PHP file was generated by PEMapModder's ZIP-PHAR converter (" . \WEBSITE_NAME . ").
";
		if(($this->flags & self::FLAG_APPEND_ORIGINAL_BASE64) === self::FLAG_APPEND_ORIGINAL_BASE64){
			$output .= " * The following is the base64 representation of the file before being tuned:
 * " . base64_encode($originalContents) . "
";
		}
		$output .= " * Disclaimer: This file is automatically generated and modified using the sources from uploads. " . WEBSITE_NAME . " is not to be held accountable for any illegal uses from users of this website, including but not limited to copyright breaches.
 */";
		return $output;
	}
	private function isNonSymbol($ascii){
		return ord("A") <= $ascii and $ascii <= ord("Z") or ord("a") <= $ascii and $ascii <= ord("z") or ord("0") <= $ascii and $ascii <= ord("9") or $ascii === ord("_") or $ascii === ord('$');
	}
}
